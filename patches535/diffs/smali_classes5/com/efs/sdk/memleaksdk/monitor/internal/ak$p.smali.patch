--- a/smali_classes5/com/efs/sdk/memleaksdk/monitor/internal/ak$p.smali
+++ b/smali_classes5/com/efs/sdk/memleaksdk/monitor/internal/ak$p.smali
@@ -31,8 +31,6 @@
     .line 2
     invoke-direct {p0, p1, p2, v0}, Lcom/efs/sdk/memleaksdk/monitor/internal/ak;-><init>(Ljava/lang/String;IB)V
 
-    .line 3
-    .line 4
     .line 5
     return-void
 .end method
@@ -57,48 +55,36 @@
     .line 1
     const-string p0, "references"
 
-    .line 2
     .line 3
     invoke-static {p1, p0}, Lkotlin/jvm/internal/Intrinsics;->g(Ljava/lang/Object;Ljava/lang/String;)V
 
-    .line 4
-    .line 5
     .line 6
     sget-object v0, Lcom/efs/sdk/memleaksdk/monitor/internal/ak;->ao:Lcom/efs/sdk/memleaksdk/monitor/internal/ak$v;
 
-    .line 7
     .line 8
     const/4 v4, 0x0
 
     .line 9
     const/16 v5, 0x8
 
-    .line 10
     .line 11
     const-string v1, "android.os.Message"
 
-    .line 12
     .line 13
     const-string v2, "obj"
 
-    .line 14
     .line 15
     const-string v3, "A thread waiting on a blocking queue will leak the last dequeued object as a stack local reference. So when a HandlerThread becomes idle, it keeps a local reference to the last message it received. That message then gets recycled and can be used again. As long as all messages are recycled after being used, this won\'t be a problem, because these references are cleared when being recycled. However, dialogs create template Message instances to be copied when a message needs to be sent. These Message templates holds references to the dialog listeners, which most likely leads to holding a reference onto the activity in some way. Dialogs never recycle their template Message, assuming these Message instances will get GCed when the dialog is GCed. The combination of these two things creates a high potential for memory leaks as soon as you use dialogs. These memory leaks might be temporary, but some handler threads sleep for a long time. To fix this, you could post empty messages to the idle handler threads from time to time. This won\'t be easy because you cannot access all handler threads, but a library that is widely used should consider doing this for its own handler threads. This leaks has been shown to happen in both Dalvik and ART."
 
-    .line 16
     .line 17
     invoke-static/range {v0 .. v5}, Lcom/efs/sdk/memleaksdk/monitor/internal/ak$v;->b(Lcom/efs/sdk/memleaksdk/monitor/internal/ak$v;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lkotlin/jvm/functions/Function1;I)Lcom/efs/sdk/memleaksdk/monitor/internal/bn;
 
-    .line 18
-    .line 19
     .line 20
     move-result-object p0
 
     .line 21
     invoke-interface {p1, p0}, Ljava/util/Collection;->add(Ljava/lang/Object;)Z
 
-    .line 22
-    .line 23
     .line 24
     return-void
 .end method
